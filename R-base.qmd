# R Programına Giriş {#sec-Rbase}

`R`, veri analizi, grafik oluşturma ve istatistiksel hesaplamalar için tasarlanmış, açık kaynaklı bir programlama dili ve yazılım ortamıdır.^[<https://www.r-project.org/about.html>] Dünya çapında geniş bir kullanıcı ve geliştirici topluluğuna sahip olan `R`, katkıda bulunanların desteği ile sürekli olarak zenginleşen bir ekosistem oluşturmuştur. `R` Vakfı, `R`'yi salt bir istatistik sistemi olarak görmekten ziyade, *istatistiksel tekniklerin uygulanabileceği esnek bir platform* olarak tanımlamayı tercih etmektedir.^[Detaylar için bkz. <https://www.r-project.org/foundation/>]

`R`'nin gerçek gücü, özelleştirilebilir paket (kütüphane) yapısından gelir. `R` programının çekirdek dağıtımında yer alan temel paketlerle başlar ve CRAN (Comprehensive R Archive Network) gibi depolarda yer alan binlerce ek paket ile sınırları genişletilebilir.^[<https://cran.r-project.org/>] Bu paketler, en son istatistiksel tekniklerden veri işleme ve görselleştirme araçlarına kadar geniş bir yelpazeyi kapsar.

İzleyen altbölümde, önce `R`'nin temel kurulumunu nasıl yapacağımızı göreceğiz. Ardından, `R`'nin gücünü ve erişilebilirliğini artıran `RStudio` adlı kullanıcı dostu Entegre Geliştirme Ortamı'nın (IDE) kurulumu ve kullanımı üzerine yoğunlaşacağız. Bu kitapta kullanacağımız temel araç olan `RStudio`, `R` ile çalışmayı daha verimli ve keyifli hale getiren ekstra özellikler sunmaktadır.


## Kurulum {#R-kurulum}

`R` ve `RStudio` bilgisayarınızda yüklü değilse ya da eski versiyonları yüklüyse, aşağıdaki adımları takip ederek en güncel versiyonlarını yükleyebilirsiniz:

1.  Önce CRAN adresinden, <https://cran.r-project.org/>, `R`'ın sisteminize uygun en son versiyonunu indirerek kurunuz. Kurulumdan sonra programı çalıştırdığımızda `R` komut penceresine (Console) ulaşabiliriz (bkz. @fig-R1)   

::: {#fig-R1 }
![](img/Rimage1.PNG){width=80%}

R programının arayüzü ve komut satırı
::: 

Bu aşamada temel `R` fonksiyonlarını kullanmaya başlayabilirsiniz. Örneğin, aşağıdaki komutları sırasıyla yazarak simülasyonla oluşturduğumuz 50 gözlemli verilerin bir serpilme grafiğini çizebiliriz: 
```{r eval=FALSE, include=TRUE}
x = rnorm(50)
y = 1 + 2*x + rnorm(50)
plot(x, y)
```
Bu programın çıktısı için bkz. @fig-R2. 

::: {#fig-R2 }
![](img/Rimage2.PNG){width=80%}

R programının komut satırı ve grafik penceresi
::: 


Ancak standart `R` arayüzü (`R` GUI) ile kod yazmak, proje hazırlamak ve yönetmek kolay olmayabilir. Bu işleri kolaylaştırmak için yaygın olarak kullanılan bir arayüz `RStudio` programıdır. `RStudio`, `R` için popüler bir entegre geliştirme ortamı (IDE) olup, temel `R` arayüzüne göre çeşitli avantajlar sunar. Bunlar arasında gelişmiş kod düzenleme seçenekleri, paket yönetimi ve entegre yazılım geliştirme ortamı, proje yönetimi, R Markdown ve Quarto gibi dinamik rapor ve belge oluşturma seçenekleri ve geniş kullanıcı topluluğu ve desteği sayılabilir. 

2. `RStudio` adresine,  <https://rstudio.com/>, giderek bilgisayar sisteminize uygun programı kurunuz.

::: {#fig-R3 }
![](img/RStudio5.PNG){width=80%}  

RStudio programı
::: 

`RStudio` programını çalıştırdığımızda karşımıza dört pencere çıkmaktadır (bkz. @fig-R3): 

**A penceresi**: Sol altta yer alana komut satırı (console) ile programı kullanmaya başlayabiliriz. Konsolun yanındaki sekmeler terminal, arkaplan işleri ve R Markdown gibi diğer RStudio özelliklerine erişim için kullanılır. Ayrıca hata mesajları ve uyarılar da bu pencerede görülür. 

**B penceresi**: Sol üst tarafta yer alan pencere dosya düzenleyicisidir. Bu alanda çeşitli dokümanlar oluşturabilir, komutları bir `R script` dosyası içinde düzenleyebilir ve kaydedebiliriz. Editör, kod tamamlama, sözdizimi vurgulama ve kod parçalarını yürütme gibi özelliklere sahiptir. Örneğin, uzantısı `.R` olan bir kod dosyası (script) oluşturmak için `File > New File > R script` adımlarını takip edebilirsiniz. New file altında çok sayıda dosya biçimi dikkatinizi çekmiştir. Örneğin bu kitap `R Quarto` dosya biçimi (`.qmd` uzantılı) ile oluşturulmuştur. 

**C penceresi**: `RStudio` programının sağ üst kısmındaki pencerede mevcut çalışma oturumuna ilişkin çeşitli bilgiler, veri kümeleri ve fonksiyonlar yer almaktadır (Environment, History). Burada hafızada yer alan nesnelerin bir listesi ve özellikleri ile geçmiş komutların bir listesi yer almaktadır.  

**D penceresi**: Sağ alt pencerede ise farklı sekmelerde dosyaların bir listesi ve özellikleri, oluşturulan grafikler, aktif olan paketlerin listesi, yardım dosyaları ve diğer bilgiler yer almaktadır (bkz. @fig-R3).  

`RStudio` sadece basit bir arayüz olmanın ötesinde karmaşık dokümanlar oluşturulması, yazılım projelerinin geliştirilmesi ve yönetilmesi gibi çok sayıda fonksiyona sahiptir. Bu özellikleriyle `R` ve `Python` gibi programlama araçlarını kullanan istatistikçi ve veri bilimciler arasında oldukça popülerdir.   


## RStudio Komut Satırı {#R-console}

Alt solda (bkz. @fig-R3, A penceresi) yer alan `R Console` penceresini kullanarak doğrudan komutlarınızı çalıştırabilirsiniz. Kısa komutlar için pratik olsa da ciddi analizler için bir *R Script* dosyası tutmanız daha sağlıklı olacaktır.

### Aritmetik işlemler 

Komut satırında basit aritmetik işlemler kolayca yapılabilir: 
```{r}
A = 5 + 3 # toplama 
B = 5 - 3 # çıkarma 
C = 5 * 3 # çarpma 
D = 5 / 3 # bölme 
E = 5 ^ 3 # üst alma 
```

Atama işlemi `=` ya da `<-` ile yapılabilir:
```{r}
x <- A/B 
print(x)
```
Bilgisayarlarda yaptığımız aritmetik işlemlerin sonucu beklediğimizden farklı olabilir. Örneğin 
$$
a = (9\times 8.1) + 8.1
$$ 
işleminin sonucunun $10\times 8.1 = 81$ olduğunu biliyoruz. Komut satırında bunu hesaplayalım:
```{r}
a <- 9*8.1 + 8.1
print(a)
```
Daha yakından bakarsak
```{r}
print(a, digits = 17)
```
bu sonucun tam olarak 81 olmadığını görebiliriz. Bunun nedeni bilgisayarlarda sayıların ikili sistem temsilindeki (floating point arithmetic) hatadır. Bu işlemde bu hata yaklaşık olarak  

```{r}
print(81-a, digits = 17)
```
yani $1.4210854715202004\times 10^{-14}$, ya da
```{r}
format(81-a, scientific = FALSE)
```

kadardır. Bu, çoğu durumda gözardı edilebilse de yaptığınız hesaplamanın amacına bağlı olarak sorun yaratabilir. Örneğin, yazdığınız programda bir aritmetik işlemin sonucunu başka bir sonuçla karşılaştırmak istediğinizi düşünelim. Bunun için, daha sonra detaylı olarak inceleyeceğimiz `R`'ın mantıksal işlemcilerini kullanabiliriz. Örneğin elde ettiğimiz sonucun 81'e eşit olup olmadığını sorgulamak istediğimizi düşünelim: 
```{r}
81 == a # boşluksuz iki eşit işareti mantıksal kıyaslama yapar
```
Buna göre bildiğimiz tam sonuç (81) ile aritmetik işlemin sonucu (`a`) eşit değil. Aslında eşit olduklarını biliyoruz. Ancak bilgisayar temsilinde yaklaşık olarak eşittirler: 

```{r}
all.equal(81,a)
```
Burada öntanımlı tolerans düzeyi olan $0.000000015$ kullanıldı. Yani aritmetik çözüm ile tam sonuç arasındaki fark tolerans düzeyinden küçüktür.

`R`'da makine hassasiyeti ($\epsilon$) ya da diğer bir deyişle makine epsilonu, çift duyarlıklı (double precision) kayan nokta sayılarının gösterebileceği en küçük pozitif sayıdır. Bu sayı, 1.0'a bu değeri eklediğinizde 1.0'dan farklı olarak algılanacak en küçük artışı ifade eder. `R`'da bu değer `.Machine$double.eps` ile sorgulanabilir: 

```{r}
print(.Machine$double.eps, digits=22)
```
Örneğin bilgisayarda temsil edilebilen 1'den büyük olan en küçük sayıyı bulalım: 
```{r, echo=TRUE, eval=TRUE}
eps <- .Machine$double.eps
u <- 1 + eps
print(u, digits=22) 
u>1
```

Nümerik hesaplamaların özellikleri için `?.Machine` komutunu kullanarak yardım dosyasını inceleyebilirsiniz.  IEEE 754 çift hassasiyetli sayı temsil standardına göre^[Bkz. <https://en.wikipedia.org/wiki/IEEE_754>] yaklaşık olarak $2^{-1022}$ olarak tanımlı en küçük pozitif çift hassasiyetli sayı 
```{r}
.Machine$double.xmin
```

olarak tanımlıdır. 


Hesaplamalarda diğer aritmetik işlemlerin de sorun yaratabileceği göz ardı edilmemelidir. Örneğin aşağıdaki çıkarma işlemini düşünelim: 
```{r}
b <- 10.2 - 10.1
print(b, digits = 17)
```
Bunun tam sonuç olan $0.10$ ile aynı olmadığı görülmektedir.

**Alıştırma** 81 sayısının ikili sistemde gösteriminin $(1010001)$ olduğunu, yani, $(81)_{10} = (1010001)_2$ yazılabileceğini gösteriniz. Ayrıca $0.10$'in ikili gösterimini bulunuz.

```{r}
#| echo: false
#| output: false

decimal_to_binary <- function(num) {
  binary <- rev(as.integer(intToBits(num)))
  # Sıfırları baştan kırpıyoruz
  binary <- binary[which(binary == 1)[1]:length(binary)]
  paste(binary, collapse = "")
}

decimal_to_binary(81)
```

```{r}
#| echo: false
#| output: false
#| 
# Ondalık sayıyı ikili sisteme çeviren fonksiyon
decimal_to_binary_fraction <- function(decimal, precision = 20) {
  result <- ""
  frac_part <- decimal
  for (i in 1:precision) {
    frac_part <- frac_part * 2
    if (frac_part >= 1) {
      result <- paste0(result, "1")
      frac_part <- frac_part - 1
    } else {
      result <- paste0(result, "0")
    }
    if (frac_part == 0) break
  }
  result
}

decimal_to_binary_fraction(0.10)
```



### Yerleşik sabitler ve fonksiyonlar 

`R`'da çok sayıda yerleşik sabitler, matematiksel fonksiyonlar, ve özel tanımlı nesneler bulunur. Örneğin $\pi$ sayısı  

```{r}
pi
```
ile tanımlanır. 

`R`'da `log()` doğal logaritma olarak öntanımlıdır: 
```{r}
log(exp(1))
```
Üstel fonksiyon ve $e$ sayısı için:  
```{r}
e <- exp(1)
print(e, digits = 3)
```
$e$ sayısının noktadan sonraki 16 basamağını bulalım: 
```{r}
print(e, digits = 17)
```

10 ve 2 tabanlı logaritmalar için `log10()` ve `log2()` kullanılabilir: 
```{r}
log10(100)
```
```{r}
log2(16)
```

`R`da tanımlı diğer özel nesneler şunlardır: `Inf` ve `-Inf` artı ve eksi sonsuzu, `NA` (not available) kayıp değerleri, `NaN` (not a number) tanımsız bir işlem sonucunu ifade eder: 
```{r}
1/0
-1/0
0/0
```



## `R`'da Nesneler {#R-nesne}

`R`'da her şey bir nesnedir (object) ve tüm işlemler bu nesneleri üzerinden yapılır. Nesne temelli yaklaşım, veri analizi ve istatistiksel modelleme için doğal bir çerçeve sunmaktadır. Nesneler, sayılar, vektörler, matrisler, veri çerçeveleri, fonksiyonlar gibi veri yapılarını temsil edebilir.  

`R` nesne tanımında büyük-küçük harf ayırımı yapar, yani `x` ve `X` farklı nesnelerdir. Hafızadaki tüm nesneleri görmek için `ls()` komutu kullanılabilir:  

```{r}
ls()
# ya da objects()
```

Mevcut oturumda aktif olan nesnelerin listesine ulaşmak için `RStudio`'da sağ üst pencerede `Environment` sekmesine bakılabilir. `rm(x)` komutu `x` nesnesini hafızadan siler. Tüm nesneleri silmek istersek

```{r, eval = FALSE}
rm(list=ls())
ls()
```

komutunu kullanabiliriz. 

Nesne isimleri rakamla başlayamaz, virgül ve boşluk içeremez (nokta içerebilir). Örnek olarak komut satırında aşagıdaki işlemleri yapınız:

```{r eval=FALSE, include=TRUE}
2nesne <- c(10, 20)
```
Bu işlem hata verecektir: `Error: unexpected symbol in "2nesne"`. Nesne isimlerinin rakamla başlayamayacağını belirtmiştik. 

```{r}
nesne2 <- c(10, 20)
nesne2
```

Bunun dışında nesnelerin isimlendirilmesinde bir zorunluluk yoktur. Ancak isimlendirmelerde kodun anlaşılır ve kolayca düzenlenebilir olmasına dikkat etmek faydalı olacaktır. Nesnelerin isimlerinin içeriklerini açık ve anlaşılır şekilde yansıtmasına dikkat edilebilir. Nesnelerin isimlendirilmesinde yaygın kullanılan örnekler şunlardır: 

```{r}
# Örnek 1 (snake_case)
yeni_bir_nesne <- nesne2*5
yeni_bir_nesne
```

```{r}
# Örnek 2 (CamelCase)
YeniBirNesne <- nesne2*5
YeniBirNesne
```

```{r}
# Örnek 3
yeni.bir.nesne <- nesne2^3
yeni.bir.nesne
```

`R`'da temel nesne türleri şunlardır:

    - Vektör: nümerik, karakter, mantıksal, tamsayı
    - Matris
    - Liste
    - Veri çerçevesi (data frame)

`R`'da bir nesnenin sınıfını ve türünü öğrenmek için `class()` ve `typeof()` fonksiyonları kullanılabilir:
```{r}
class(yeni_bir_nesne)
```

```{r}
typeof(yeni_bir_nesne)
```


## Vektörler {#R-vektor}

Bir `R` vektörü (ya da bir atomik vektör) bir değer ya da bilgi topluluğudur. Sayısal ya da sayısal olmayan elemanlar içerebilir. Ancak sadece bir türde değer içerebilir: reel sayılar (doubles), tamsayılar (integers), karakterler (characters), mantıksal sonuçlar (logicals) ve kompleks sayılar.

`R`'da vektör ya da liste oluşturmanın en kolay yolu `c()` komutudur. Örneğin, aşağıdaki örnekte olduğu gibi `c()` fonksiyonuyla `a` ve `b` vektörlerini oluşturabiliriz:

```{r}
a <- c(1,2,3,4,5)  # bir sayısal vektör oluştur
typeof(a)          # vektörün türü
print(a)
```

```{r}
b <- rep(1,5) # tüm elemanları 1 olan 5 elemanlı bir vektör oluştur
a+b
```
Vektör öğelerine isim verilebilir:

```{r}
puanlar <- c("Ahmet" = 80, "Burcu" = 95, "Hasan" = 67)
print(puanlar)
```

```{r}
names(puanlar)
```
### Sayısal Vektörler 

Sayısal vektörler, `R`'da veri analizi ve istatistiksel hesaplamalar için temel yapı taşlarından biridir. Bu vektörler, sayısal (nümerik) değerlerin dizilerini içerir ve genellikle hesaplamalar, analizler ve veri görselleştirmeler için kullanılır. Tüm elemanları tamsayı ya da reel sayılardan oluşan vektörlerdir. 

Sayısal bir vektör oluşturmak için `c()` fonksiyonu kullanılır. Bu fonksiyon, içine yazılan değerleri birleştirerek bir vektör oluşturur. Örneğin:
```{r}
sayisal_vektor <- c(2, 4, 6, 8, 10)
sayisal_vektor
```


Tüm elemanları sıfır olan 5 öğeli bir vektör oluşturmak istersek `numeric()` fonksiyonunu kullanabiliriz: 
```{r}
sifirlar <- numeric(5)
sifirlar 
```

Sayısal vektörler, hem tamsayıları (integers) hem de reel sayıları (doubles) içerebilir. Tamsayılar için sonlarına `L` eklenir:  
```{r}
tamsayilar <- c(1L, 2L, 3L)
tamsayilar
typeof(tamsayilar)
```
```{r}
reel_sayilar <- c(1.5, 2.5, 3.5)
reel_sayilar
typeof(reel_sayilar)
```

Örnek: `skor` vektörü bir ürün için 100 üzerinden değerlendirmeleri göstersin:
```{r}
skor <- c("Denek 1" = 80, "Denek 2" = 65, "Denek 3" = 78, "Denek 4" = 94, "Denek 5" = 100, "Denek 6" = NA, "Denek 7" = 55, "Denek 8" = 85, "Denek 9" = 88, "Denek 10" = 75)
print(skor)
```

Yaygın kullanılan sayısal vektör fonksiyonları şunlardır: 

```{r, eval=TRUE}
# vektörün eleman sayısı 
length(a) # ya da NROW(a)
# sırala
sort(skor) # default: küçükten büyüğe, NA hariç
# maximum 
max(a)
# minimum
min(a)
# elemanların toplamı
sum(a)
# elemanların çarpımı
prod(a) 
# Tüm elemanları a olan n-vektör: rep(a, n)
rep(1,10)
# seq(T): 1'den  T'ye tamsayı dizisi
seq(10)
# seq(t,T) t'den T'ye tamsayı dizisi
seq(5,10)
# seq(t,T,s) t'den T'ye s artışla tamsayı dizisi
seq(1,10,2)
```

Bir vektörün elemanlarına ulaşmak için `[ ]` ile pozisyonu (indeksi) bildirmemiz gerekir. İlk elemanın indeksi 1'dir:
```{r}
# 1nci eleman
skor[1]
```
Belirli bir aralıktaki elemanları seçmek için:
```{r}
# 2-4 elemanlar
skor[2:4]
```

```{r}
# son eleman
n <- length(skor)
skor[n]
```


```{r}
# son 3 eleman
skor[(n-3):n]
```

**Alıştırma** `skor[(n-3):n]` yerine `skor[n-3:n]` kullanınız. Sonucu tartışınız.

```{r}
skor[n-3:n]
```

Mantıksal ifadelerle belirli koşulları sağlayan elemanları seçmek mümkündür. Mantıksal vektörler izleyen bölümde ele alınmaktadır. Bu aşamada sayısal vektörlerle mantıksal karşılaştırmaların nasıl yapılabileceğine ilişkin bir örnek görelim: 
```{r}
sayisal_vektor <- c(2, 4, 6, 8, 10)
besten_buyuk_mu <- sayisal_vektor > 5
besten_buyuk_mu
```
Bu örnekte bir sayısal vektör oluşturduk ve `sayisal_vektor > 5` ifadesini kullanarak bu koşulun doğru ya da yanlış olup olmadığını ekrana yazdık. Bu koşulu sağlayan, yani beşten büyük olan elemanları görmek istersek köşeli parantezi kullanabiliriz: 
```{r}
sayisal_vektor[besten_buyuk_mu]
```
Aynı sonuca 
```{r}
sayisal_vektor[sayisal_vektor > 5]
```
komutu ile de ulaşılabilir. 



### Karakter Vektörleri {#R-kar-vek}

`R`'da karakter vektörleri, metin (string) tabanlı verileri saklamak için kullanılır. Her öğe, alfanümerik karakterler, boşluklar veya özel karakterler içeren bir metin parçasıdır. Bu vektörler, veri analizinde metin tabanlı veri işleme için temel yapı taşlarından biridir.

Bir karakter vektörü oluşturmak için `c()` fonksiyonu kullanılır. Her eleman çift tırnak işaretleri, `" "`, ya da `' '`,  içinde belirtilir: 

```{r}
isimler <- c("Ahmet", "Burcu", "Cem") # 3 elemanlı bir karakter vektörü
isimler
typeof(isimler)
```

Boş bir karakter vektörü oluşturmak istersek `character()` fonksiyonunu kullanabiliriz: 
```{r}
kar <- character(5) # 5 elemanlı bir boş karakter vektörü oluştur
kar
```
Bir karakter dizisinin uzunluğunu öğrenmek için `nchar()` fonksiyonu kullanılır:
```{r}
nchar("Merhaba Dünya")
```
Burada boşlukların da sayıldığına dikkat ediniz. Bu fonksiyonu bir karakter vektörüne de uygulayabiliriz:  
```{r}
# bir karakter vektöründeki ögelerin uzunluğu
nchar(isimler) 
nchar(kar)
```

Karakter vektörleri üzerinde birçok işlem gerçekleştirilebilir. Örneğin, iki metin parçasını birleştirmek için `paste()` veya `paste0()` fonksiyonları kullanılır:
```{r}
#  iki ayrı metin parçasından yeni bir metin oluşturma
kelime1 <- "Merhaba"
kelime2 <- "Dünya"
tam_cumle <- paste(kelime1, kelime2)
tam_cumle
```
Bir karakter dizisinden belirli bir bölümü ayıklamak için `substr()` fonksiyonu kullanılır. Eğer `x` bir karakter vektörü ise belirli bir aralıktaki karakterleri ayıklamak için 
```{r eval=FALSE}
substr(x, start, stop)
```
kullanılabilir. Örneğin,
```{r}
substr("abcdef", 3, 4)
```

```{r}
metin <- "R programlama dili"
altMetin <- substr(metin, 3, 13)
altMetin
```
Metnin belirli bir kısmına değiştirmek istersek yine aynı komutu kullanabiliriz: 
```{r}
alf <- "abcdef"
substr(alf, 1, 2) <- "AB"
```

Karakter vektörlerini alfabetik olarak sıralamak için `sort()` fonksiyonu kullanılır:
```{r}
isimler <- c("Hasan", "Elif", "Zeynep", "Ahmet", "Çetin", "Burcu")
sort(isimler)
```
Karakter dizilerinde desenleri (pattern) bulma ve değiştirme işlemleri için `grep()`, `grepl()`, `gsub()` ve `sub()` gibi fonksiyonlar kullanılır.

`grep()` fonksiyonu, belirli bir desen veya ifadeyi bir karakter vektörü içinde aramak için kullanılır ve eşleşen öğelerin indekslerini döndürür. Örnek olarak, diyelim ki, çeşitli meyve isimlerinin bulunduğu bir karakter vektörümüz var ve bu vektör içinde "elma" kelimesini içeren tüm öğeleri bulmak istiyoruz.
```{r}
# Meyve isimlerini içeren bir karakter vektörü
meyveler <- c("elma", "muz", "portakal", "elma ve armut", "kivi", "armut")

# "elma" kelimesini içeren öğeleri arayalım
elma_indisleri <- grep("elma", meyveler)

# Eşleşen öğelerin indeksleri (sıra numaraları)
print(elma_indisleri)
```
Bu kod, meyveler vektöründe "elma" kelimesini içeren öğelerin sırasını bulur ve yazdırır. Bu durumda, "elma" ve "elma ve armut" ifadelerini içeren öğelerin sıra numaraları, 1 ve 4, çıktı olarak yazılmıştır. 

`grepl()` fonksiyonu, bir karakter vektörü içinde belirli bir deseni veya metni arar ve her öğe için mantıksal bir değer (TRUE veya FALSE) döndürür. Bu, belirli bir desenin varlığını her öğe için kontrol etmek istediğinizde kullanışlıdır. Örneğin, çeşitli şehir isimlerini içeren bir karakter vektörünüz var ve bu şehir isimleri arasında "Ankara" kelimesini içerenleri bulmak istiyorsunuz.
```{r}
# Şehir isimlerini içeren bir karakter vektörü
sehirler <- c("İstanbul", "Ankara", "İzmir", "Bursa", "Ankara ve Konya", "Antalya")

# "Ankara" kelimesini içeren öğeleri bulalım
ankara_var_mi <- grepl("Ankara", sehirler)

# Her öğe için mantıksal değerler
print(ankara_var_mi)
```
Bu kod, sehirler vektöründe her öğe için "Ankara" kelimesinin varlığını kontrol eder ve her öğe için bir mantıksal değer (TRUE veya FALSE) döndürür. Örneğin, "Ankara" ve "Ankara ve Konya" ifadelerini içeren öğeler için TRUE değeri yazılır. 

`grepl()` genellikle koşullu ifadelerde ya da veri alt kümesi oluşturmak için kullanılır. Örneğin, sadece "Ankara" içeren şehir isimlerini bir alt küme olarak almak istersek:
```{r}
# Sadece "Ankara" içeren şehirleri filtreleyelim
ankara_iceren_sehirler <- sehirler[grepl("Ankara", sehirler)]

# Filtrelenmiş liste
print(ankara_iceren_sehirler)
```
Bu kod, "Ankara" kelimesini içeren şehir isimlerini bir alt küme olarak döndürür. `grepl` fonksiyonu, verileri filtrelemek ve belirli koşullara göre alt kümeler oluşturmak için oldukça kullanışlıdır.

`R`'da `sub()` fonksiyonu, bir karakter dizisi içinde belirli bir deseni bulur ve bu deseni başka bir metinle değiştirir. Ancak, bu değişikliği yalnızca ilk eşleşme için yapar. Örneğin, bir cümle içindeki ilk "elma" kelimesini "armut" ile değiştirmek istiyorsak: 
```{r}
# Bir cümle
cumle <- "elma ve muz, elma ve kiraz"

# İlk "elma" kelimesini "armut" ile değiştirelim
yeni_cumle <- sub("elma", "armut", cumle)

# Yeni cümle
print(yeni_cumle)
```
Bu kod, `cumle` içindeki ilk "elma" kelimesini "armut" ile değiştirir ve güncellenmiş cümleyi yazdırır. Yani, "elma ve muz, elma ve kiraz" olan cümle "armut ve muz, elma ve kiraz" olarak değişir.

Eğer metindeki tüm "elma" kelimelerini değiştirmek isterseniz, `gsub()` fonksiyonunu kullanabilirsiniz:
```{r}
# Tüm "elma" kelimelerini "armut" ile değiştirelim
tumunu_degistir <- gsub("elma", "armut", cumle)

# Yeni cümle
print(tumunu_degistir)
```
Bu örnekte, `gsub()` fonksiyonu `cumle` içindeki tüm "elma" kelimelerini "armut" ile değiştirdi. Yani, "elma ve muz, elma ve kiraz" olan cümle "armut ve muz, armut ve kiraz" olarak yeniden tanımlandı. 


`R` programlama dilinde, düzenli ifadeleri (regular expressions) kullanarak karakter dizileri üzerinde ileri düzey işlemler yapmamıza olanak tanıyan `regexpr()` ve `gregexpr()` gibi çok sayıda fonksiyon vardır. Bu fonksiyonlar, metin içindeki desenleri (patterns) bulmak ve analiz etmek için oldukça güçlü araçlardır. `regexpr()` fonksiyonu, bir karakter dizisi içinde belirli bir düzenli ifadeyi arar ve ilk eşleşmenin konumunu döndürür. Ayrıca, eşleşmenin uzunluğu ve diğer ayrıntılar hakkında bilgi verir. Bu fonksiyon, metin içindeki belirli desenleri bulmanın yanı sıra, desenin metindeki konumu hakkında da detay sağlar. 

`gregexpr()` ise, `regexpr()`'in genelleştirilmiş bir versiyonudur ve bir karakter dizisi içinde belirtilen düzenli ifadenin tüm eşleşmelerini bulur. Bu fonksiyon, metin içindeki tüm eşleşmelerin konumlarını ve uzunluklarını vererek, desenlerin metinde nasıl dağıldığını analiz etmemize olanak tanır.

Bu fonksiyonlar, metin analizi ve veri temizleme işlemlerinde oldukça yararlıdır, ancak düzenli ifadelerin kullanımı ve bu fonksiyonların detayları, başlı başına kapsamlı bir konudur. Daha fazla bilgi ve ileri düzey uygulamalar için, `R`'ın resmi belgelerine, yardım dosyalarına ve dokümantasyonlara ve ileri düzey kaynaklara bakılabilir.   



### Mantıksal vektörler {#R-log-vek}


`R`'da TRUE ve FALSE yerleşik isimlerdir, kullanıcılar tarafından değiştirilemez.

Tüm öğeleri yanlış (`FALSE`) olan bir mantıksal vektör oluşturalım: 

```{r}
mantiksal <- logical(5)
mantiksal
```


Yukarıda belirttiğimiz gibi, `TRUE` ve `FALSE` rezerve kelimelerdir.

```{r}
# mantıksal işlemler, ==, !=, >, <, >=, <=
0 == 0
0 == 1
```

```{r}
print(a)
# 2'den büyük sayılar
a >= 3
```

Arka planda bu kelimelerin karşılığı nümerik olarak `TRUE` (T) için 1 `FALSE` (F) için 0'dır. Örneğin,

```{r}
logic1 <- c(TRUE, FALSE, TRUE)
logic1
as.numeric(logic1) 
```

Mantıksal vektörlerle aritmetik işlem yapılırken dikkat edilmelidir. `R` bu durumda mantıksal sonuçları 0/1 değerlerinden oluşan sayısal vektöre dönüştürür. Örneğin,
```{r}
# parantez içinde mantıksal karşılaştırma: 
1-(a<=3)
```
Parantez içindeki işlemin önceliği vardır. Parantezi kaldırırsak 
```{r}
1-a<=3
```
sonucunu elde ederiz. Bu istediğimiz sonuç olmayabilir. 


Mantıksal işlemcileri, yani, `==`, `>`, `<`, `>=`, `<=` ,`!=`, kullanarak yeni vektörler oluşturabiliriz. Örneğin, yukarıda oluşturduğumuz `skor` nesnesinde 
```{r}
skor
```
70'ten küçük değerleri bulalım:
```{r}
dusuk_skorlar <- (skor < 70)
dusuk_skorlar
```
Değerlendirme notu 70'den küçük olanları bulmak istersek mantıksal ifadeleri vektör elemanlarına ulaşmakta kullanabiliriz (*logical subscripting*). Yukarıda oluşturduğumuz mantıksal vektörden hareketle:

```{r} 
skor[dusuk_skorlar]
```
Kayıp gözlemlerin mantıksal ifadelerde dikkate alınmadığını ve çıktıda yer verildiğini görüyoruz. 

 **Alıştırma** `skor` vektöründe kayıp değerleri `NA` bulunuz ve yeni bir vektör yaratarak bu değerleri siliniz.

**Çözüm** Bunun en basit yolu temel `R`'da yer alan `which()` ve `is.na()` fonksiyonlarını kullanmaktır. `is.na()` fonksiyonu `NA` elemanlar için mantıksal değer `TRUE` olmayanlar için `FALSE` değerini içeren bir mantıksal vektör oluşturur.\

```{r}
# öğe NA mı ?
is.na(skor)
```

`which()` ise `NA` olan elemanların pozisyonunu (indeks bilgisini) verir.

```{r}
# NA'nın konumunu bul
which(is.na(skor))
```

Ya da `NA` olmayan elemanların indeks bilgisini oluşturmak istersek:

```{r}
# sayısal öğelerin konumu
which(!is.na(skor))
```

Burada `!is.na()` kayıp olmayan elemanları seçer (`!` olumsuzlama operatörüdür). Şimdi `NA` olan elemanı dışlayıp yeni bir vektör içinde kaydedelim:

```{r}
skor2 <- skor[which(!is.na(skor))]
skor2
```

Aslında `which()` bu örnekte gereksizdir (ara adımları istemiyorsak):

```{r}
skor2 <- skor[!is.na(skor)]
skor2
```

Kayıp gözlemleri silmek için tasarlanmış olan `na.omit()` fonksiyonu da kullanılabilir.

## Matrisler {#R-matris}

-   `R`'da matris oluşturmanın en kolay yolu `matrix()` fonksiyonudur. Örneğin, `skor` vektöründen hareketle $10\times 1$ matris oluşturalım:\

```{r}
A <- matrix(data = skor, nrow=10, ncol=1, byrow = FALSE, dimnames = NULL)
print(A)
dim(A) # matrisin boyutları satır x sütun
```

-   İstersek satır ve sütunları isimlendirebiliriz:

```{r}
rownames(A) <- names(skor)
colnames(A) <- "skor"
print(A)
```

-   Matrisin boyutlarını değiştirebiliriz:

```{r}
B <- matrix(data=1:10, nrow=5, ncol=2, byrow=FALSE, dimnames=NULL)
print(B)
```

```{r}
BB <- matrix(data=1:10, nrow=5, ncol=2, byrow=TRUE, dimnames=NULL)
print(BB)
```

-   `t()` fonksiyonu ile matrisin devriği (transpose) bulunabilir:

```{r}
t(B)
```

-   Matrislerle mantıksal işlemler yapılabilir:\

```{r}
B > 5
which(B>5)
BB > 5
which(BB>5)
```

Pozisyonun sütun bazında belirlendiğine (yani matris sütun bazında vektörize edilse) dikkat ediniz.

-   Boş (sıfırlar) matrisi

```{r}
zeros <- matrix(data = 0, nrow = 5, ncol = 5)
zeros
```

-   Matris oluşturmanın başka bir yolu da mevcut vektörlerin birleştirilmesidir. Bunun için `cbind` ve `rbind` kullanılabilir. Örneğin,

```{r}
x <- cbind(b,a)
x
#  
cbind(1,1:5)
```

-   Bireylerin cinsiyetini içeren bir karakter vektörü oluşturalım:

```{r}
cinsiyet <- c("Kadın", "Erkek", "Kadın", "Kadın", "Erkek", "Kadın", "Erkek", "Erkek", "Kadın", "Kadın")
print(cinsiyet) 
table(cinsiyet)
```

-   Burada `cinsiyet` bir kategorik (ya da kesikli) değişkendir. Şimdi skor ve cinsiyet bilgisini bir araya getirelim ve buna `x` ismini verelim:

```{r}
x<- cbind(skor, cinsiyet)
x
```

-   Yukarıda `x`'in tüm elemanları karakter tipine zorlandı. Bunun nedeni R'da vektör ve matrislerin sadece tek tip (sayısal, karakter, mantıksal, vs.) değere sahip olabilmesidir.

## Listeler {#R-liste}

-   Bir `R` listesi farklı türlerde, uzunluk ve boyutlarda nesneleri içerebilen bir nesneler topluluğudur.\

```{r}
# bir R listesi oluştur
liste1 <- list(numaralar = seq(10,20,3), 
               isimler = c("Ahmet", "Burcu", "Hasan"), 
               birim_mat = diag(4)
               )
#  
liste1 
```

-   Liste içindeki nesnelerin isimleri için `names()` komutu kullanılabilir:

```{r}
names(liste1)
```

-   Bir listenin belirli bir bileşenine `liste_ismi$bilesen_ismi` ile ulaşılabilir.

```{r}
# örnek
liste1$numaralar
liste1$numaralar[1]
```

```{r}
dim(liste1$birim_mat)
```

## Veri Çerçeveleri (Data Frames) {#R-data-fr}

-   `R`'da en temel nesnelerden biri veri çerçevesi (data frame)'dir. Belirli özelliklere sahip bir liste olarak düşünülebilir.

-   Aynı uzunlukta ve farklı tipte vektörleri bir araya getirmemize olanak tanır. Örneğin

```{r}
veri1 <- data.frame(skor, cinsiyet)
veri1
```

```{r}
names(veri1)
str(veri1)
summary(veri1)
```

```{r}
# örnek veri seti simülasyonu
set.seed(123)
x1 = rnorm(100, mean=5, sd=1.2)
x2 = rnorm(100, mean=0, sd=0.8)
grup = sample(c("A", "B", "C"), 100, replace = TRUE)
y = 2 + 2*x1 - 3*x2 + 5*(grup=="B") + 8*(grup=="C") + rnorm(100) 
#
veri2 <- data.frame(y, x1, x2, grup) # veri çerçevesini oluştur
head(veri2)
```


## Temel Programlama {#R-prog}

### Mantıksal işlemler

-   Ve işlemcisi: `&`

```{r}
# doğru ve doğru = doğru
TRUE & TRUE 
```

```{r}
# doğru ve yanlış = yanlış
TRUE & FALSE 
```

```{r}
# yanlış ve doğru = yanlış
FALSE & TRUE 
```

```{r}
# yanlış ve yanlış = yanlış
FALSE & FALSE 
```

```{r}
x <- c(4, 8)
x > 3 & x < 6
```

-   Veya işlemcisi: `|`

```{r}
# doğru veya doğru = doğru 
TRUE | TRUE
```

```{r}
# doğru veya yanlış = doğru 
TRUE | FALSE
```

```{r}
# yanlış veya doğru = doğru 
FALSE | TRUE
```

```{r}
# yanlış veya yanlış = yanlış
FALSE | FALSE
```

```{r}
x <- c(4, 8)
x > 3 | x < 6
```

-   `!(X & Y)` ile `!X | !Y` aynı sonucu verir.

-   `!(X | Y)` ile `!X & !Y` aynı sonucu verir.

-   Mantıksal işlemleri kullanarak bir veri çerçevesinin satırları (gözlemler) seçilebilir:

```{r}
# grup = A olanları seç
veri2_A <- veri2[grup == "A", ]
head(veri2_A)
```

```{r}
# subset() fonksiyonu ile 
head(subset(veri2, grup=="A"))
```

```{r}
# grup = A ve grup = B olanları seç
veri2_AB <- veri2[grup == "A" | grup == "B", ]
head(veri2_AB)
```

```{r}
# %in% işlemcisi ile
# grup = A ve grup = B olanları seç
veri2_AB <- veri2[grup %in% c("A", "B"), ]
head(veri2_AB)
```

-   Veri çerçevesinden rassal olarak bazı gözlemlerin seçilmesi:

```{r}
# veri2'den 10 satırın rassal seçimi
set.seed(99)
orneklem1 <- sample(1:nrow(veri2), 10, replace = FALSE)
orneklem1 # satır numaraları
```

```{r}
# veri2'den satırları çek
veri2[orneklem1, ]
```

-   Benzer şekilde bir veri setinden bootstrap örneklemleri oluşturulabilir:

```{r}
satirno <- sample(1:nrow(veri2), nrow(veri2), replace = TRUE)
boot1 <- veri2[satirno, ]
head(boot1)
```

### Koşullu işlem

-   Koşullu işlemleri `if` `else` komutlarını kullanarak yapabiliriz. Kullanım örneği:

```{r, eval=FALSE}
if (condition) {
  ....
} else {
    ....
  }
```

-   Nümerik örnek:\

```{r}
a <- seq(1,10,1)
b <- 85
c <- "YTU"
if (typeof(b)=="double" |  typeof(b)=="integer") {
  print(b) } else {
    print("This is not a numeric object")
  }

```

```{r}
x <- -10
if (x < 0) {
    print("x negatif bir sayıdır") 
  } else if (x == 0) {
    print("x sıfıra eşittir") 
  } else {
    print("x pozitif bir sayıdır")
  }
```

### Döngüler

-   Döngü içinde işlem yapmak için `for` komutunu kullanabiliriz. Kullanım şablonu:

```{r, eval=FALSE}
for (dongu_degiskeni in vektor) { 
  }
```

Burada `dongu_degiskeni` sırasıyla `vektor` içindeki değerleri almaktadır. Örneğin,

```{r, eval=FALSE}
for (i in 1:5) { 
  print(i) 
  }
```

-   Nümerik örnek:

```{r}
for (i in 1:10){
  if (i<5) {print(i^2)}
  else {print(sqrt(i))}
}
```

-   Döngüler üç şekilde oluşturulabilir:
    -   öğeler üzerinde: `for (x in A)`
    -   nümerik konum üzerinde: `for (i in seq_along(A))`
    -   isimler üzerinde: `for (nm in names(A))`
-   Döngüleri hızlandırmanın bir yolu nümerik indisler üzerinde döngüyü çalıştırmak ve ve döngüden önce çıktı için boş bir nesne oluşturmaktır:

```{r, eval = FALSE}
sonuc <- numeric(length(A))
for (i in seq_along(A)) {
  sonuc[i] <- sqrt(A[i])
  }
```

### Fonksiyonel İşlemler

-   `lapply()` bir liste ya da vektörün tüm elemanlarına bir fonksiyonu uygular ve aynı uzunlukta bir çıktı içinde saklar. Böylece işlemleri döngü içinde yapmaya gerek kalmayabilir.

-   Örnek: `mtcars` veri setindeki değişkenlerin aritmetik ortalamalarını bulunuz. Bir data frame aynı zamanda bir liste olduğundan `lapply()` kullanılabilir:\

```{r}
liste_ort <- lapply(mtcars, mean)  # 
unlist(liste_ort)
```

-   `lapply()` içinde kendi yazdığımız fonksiyonları da kullanabiliriz.

-   Örnek: bir veri çerçevesinin sütunlarındaki kayıp gözlemleri (NA) sayınız. Veri setimiz aşağıdaki gibi olsun:

```{r}
set.seed(456)
x1 <- runif(100)
x2 <- runif(100)
x3 <- rnorm(100)
x4 <- rnorm(100)
napoz1 <- sample(1:100, sample(1:10, 1), replace = FALSE)
napoz2 <- sample(1:100, sample(1:10, 1), replace = FALSE)
x1[napoz1] <- NA
x2[napoz2] <- NA
data <- data.frame(x1, x2, x3, x4)
head(data)
```

```{r}
na_sayisi <- function(x) {
  sum(is.na(x))
}
unlist(lapply(data, na_sayisi))
```

```{r}
# ya da daha basit olarak 
unlist(lapply(data, function(x) sum(is.na(x))))
```

-   `sapply()` ve `vapply()` fonksiyonelleri `lapply()` gibi çalışır. Ancak çıktı olarak atomik vektör oluştururlar

```{r}
# data sütunları nümerik mi?
sapply(data, is.numeric)
```

```{r}
# data sütunlarında NA sayısı 
sapply(data, function(x) sum(is.na(x)))
```

```{r}
# vapply() için çıktı vektörünün türünü bildirmemiz gerekir
vapply(data, is.numeric, logical(1))
```

```{r}
# data sütunlarında NA sayısı 
vapply(data, function(x) sum(is.na(x)), numeric(1))
```

`sapply()` interaktif uygulamalarda `vapply()` ise programlamada önerilir.

-   Matris veya çok boyutlu diziler için `apply()` kullanılabilir:

```{r}
# 200 x 5 boyutlu bir uniform matris oluştur 
set.seed(789)
X <- matrix(runif(1000), ncol = 5)
colnames(X) <- letters[1:5]
head(X)
```

```{r}
# X'in sütun ortalamalarını bul 
apply(X, 2, mean) # satırlar için margin=1, sütunlar için ise 2
```

## R Fonksiyonları {#R-fonksiyon}

-   `R`'da bütün işlemler fonksiyonlarla yapılır. Tipik bir `R` fonksiyonu girdiler (argümanlar) ve çıktılardan oluşur.

-   Örneğin `mean()` fonksiyonu `skor` girdisiyle çalıştırılırsa aritmetik ortalamalar elde edilir: 
```{r}
mean(skor)
```
Burada çıktının ortalama değil `NA` olması öğelerden birinin `NA` olmasından kaynaklanır. Kayıp gözlemleri dışlayarak ortalamayı hesaplayalım: 
```{r}
mean(skor, na.rm = TRUE) # ya da mean(skor, TRUE)
```
Kullanıcı girmezse `na.rm = FALSE` değerini alır ve sonuç `NA` olur.

Benzer şekilde, örneklem standart sapması için
```{r}
sd(skor, na.rm = TRUE)
```

Bir `R` fonksiyonunun girdilerini görmek istersek `args()` komutunu kullanabiliriz: 
```{r}
args(sd) 
```
Fonksiyonu ekrana yazdırmak istersek parantez olmadan ismini yazmamız yeterli olur: 
```{r}
sd
```

Kendi fonksiyonlarımızı yazmak için `function()` komutunu kullanabiliriz. Bu fonksiyon aşağıdaki sözdizimine sahiptir: 

```{r, eval=FALSE}
fonksiyon_ismi <- function(girdi1, girdi2) {
  ... işlemler ...
  }
```

**Örnek**: Bir sayının tek mi çift mi olduğunu bulan bir fonksiyon yazalım:

```{r}
tek_cift <- function(x) {
    if (x == 0) {
      print("Girdiğiniz sayı sıfırdır!")
    } else if (x %% 2 == 0) {
      print("Çift sayı") 
    } else {
      print("Tek sayı")
    }
}
```

```{r}
# tek_cift() fonksiyonunu kullanabiliriz
tek_cift(4) 
tek_cift(5L) 
```


`R` fonksiyonları polimorfiktir; yani aynı fonksiyon, farklı tipte nesnelerle çalıştığında farklı davranışlar gösterebilir. Bu özellik, `print()`, `summary()` veya `plot()` gibi genel işlevlerin, farklı tipte nesneler için özelleştirilmiş çıktılar üretmesini sağlar.


## R Paketleri {#R-paket}

Paketler ya da kütüphaneler belirli bir görevi yerine getirmek için tasarlanmış fonksiyonlardan oluşur. `R` kurulumuyla gelen temel paketler şunlardır: 

```{r}
rownames(installed.packages(priority="base"))
```
`R` programının güçlü yanlarından biri kullanıcılar tarafından yazılmış paketlerin yüklenmesiyle geliştirilebilmesidir.

Örneğin, `{corrplot}` paketi korelasyon matrisini görselleştirir:

```{r eval=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
install.packages("corrplot", repos='http://cran.us.r-project.org')
```

Detaylar için bkz <https://cran.r-project.org/web/packages/corrplot/index.html>.

-   Alternatif olarak aynı işlem `RStudio` menüsünden de yapılabilir: `Tools>InstallPackages` ilgili pencerede "{corrplot}" paket ismini yazmamız gerekir.
-   Paketi kullanabilmek için önce yüklememiz daha sonra ise aktif hale getirmemiz gerekir:

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
library(corrplot)
kor_matris <- cor(mtcars)
corrplot(kor_matris)
```

Komut satırında `?corrplot` yazarak yardım dosyasını inceleyebiliriz (detaylı dokümantasyon dosyaları için `help(package = "corrplot")` komutu kullanılabilir) . Korelasyon matrisini nümerik değerleri kullanarak da görselleştirebiliriz. Yardım dosyasında da görüleceği gibi `method="number"` opsiyonu bu amaç için kullanılabilir:

```{r}
corrplot(kor_matris, method = "number")
```

Pakete ilişkin örnekleri çalıştırmak için komut satırında aşağıdaki kodu çalıştırınız:

```{r, eval = FALSE}
example(corrplot)
```

Pakete ilişkin diğer bilgiler için `packageDescription(" ")` komutu kullanılabilir:

```{r eval=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
packageDescription("corrplot")
```

Birden fazla paketi yüklemek istersek:

```{r eval=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
install.packages("corrplot", "MASS")
```

`R` varsayılan paket deposu [CRAN (The Comprehensive R Archive Network)](https://cran.r-project.org/) üzerinden bu iki paketi yüklemeye çalışır. CRAN deposu en popüler yollardan biri olsa da paket yüklemenin başka yolları da vardır. Örneğin, `{devtools}` paketi ile [github](https://github.com/) üzerinden ya da yerel olarak paketler yüklenebilir.

`R` topluluğu, kullanıcılar tarafından geliştirilen fonksiyonlar ve paketlerle her geçen gün büyümektedir. CRAN (Comprehensive R Archive Network) ve GitHub gibi platformlar aracılığıyla binlerce paket, `R` kullanıcılarının hizmetine sunulmuştur. Bu paketler, özel veri analizi ihtiyaçlarına yönelik çözüm sunar ve kullanıcıların kendi fonksiyonlarını yazarak `R`'ın yeteneklerini genişletmelerine olanak tanır.

Örneğin, belirli bir alanda çokça kullanılan bir analiz tekniği için henüz bir yerleşik `R` fonksiyonu yoksa, bir kullanıcı bu işlevi kendisi tanımlayabilir ve daha sonra bunu bir paket haline getirerek topluluğa katkıda bulunabilir. Bu, `R`'ın açık kaynaklı yapısının en büyük avantajlarından biridir. `R` ekosistemi, sürekli gelişen ve büyüyen bir yapıya sahiptir, bu da veri analistleri ve araştırmacılar için büyük bir avantaj sağlar.

Son yıllarda `Tidyverse` adlı paketler kümesi, `R` kullanıcıları arasında büyük bir popülerlik kazanmıştır. Tidyverse, veri analizi süreçlerini daha okunabilir, tutarlı ve etkin hale getiren bir dizi paket içerir. Bu paketlerden özellikle `dplyr` ve `ggplot2`, veri işleme ve görselleştirme konusunda standart hale gelmiştir.

   - `dplyr`: Bu paket, veri manipülasyonu için optimize edilmiş fonksiyonlar sağlar. Verileri filtrelemek, sıralamak, gruplamak ve özetlemek gibi işlemler, `dplyr`'ın sade ve anlaşılır sözdizimiyle çok daha kolay bir hale gelmiştir. Örneğin, `filter()`, `mutate()`, `summarize()` gibi fonksiyonlar, veri setleri üzerinde hızlı ve verimli işlemler yapmayı sağlar.

   - `ggplot2`: Görselleştirme konusunda `R` kullanıcılarının başvurduğu temel araçlardan biri olan `ggplot2`, veri görselleştirmeyi estetik ve esnek bir şekilde yapmayı sağlar. `ggplot2`, karmaşık grafikler üretmek için basit ve modüler bir yaklaşım sunar.

Tidyverse paketler topluluğu  hakkında daha fazla bilgi için bkz. <https://www.tidyverse.org/>. Ayrıca kısa bir giriş için bkz. <https://htastan.github.io/R-Giris/R-Tidyverse.html>.  


## Çalışma dizini {#R-dizin}

`getwd()` komutu ile güncel dizini görebiliriz:

```{r, eval=FALSE}
getwd()
```

Bunu değiştirmek istersek `setwd("/tam/adres/")` komutunu kullanabiliriz. Dizin adresinde `\` yerine `/` kullanıldığına dikkat ediniz:

```{r, eval=FALSE, echo=TRUE}
setwd("C:/Users/Folder/Another-Folder/R-uygulama-1")
```

Tipik olarak bu R dosyaları başka bilgisayarlarda çalışmaz. Her bilgisayarda bu adreslerin tekrar tanımlanması gerekebilir. Bu da hatalara davetiye çıkarır.

RStudio'da **R proje** klasörü oluşturarak çalışma dizininin otomatik olarak algılanmasını sağlayabiliriz. Bir R projesi yardımıyla dosyaların başka bilgisayarlarda da çalışması mümkün olur.

## Görselleştirme {#R-gorsel}

### Plot fonksiyonu

`plot(x, y)` iki nümerik vektör girdisini kullanarak grafiği çizer. 
```{r}
#| label: fig-plot1
#| fig-cap: "R plot fonksiyonu" 
#| echo: false
set.seed(2345)
x <- rnorm(10) 
plot(x,  
     main="Başlık 'main' ile yazılabilir", 
     type = "l", # çizgi grafiği
     xlab="x ekseninin etiketi 'xlab' ile yazılabilir", 
     ylab="y ekseninin etiketi 'ylab' ile yazılabilir", 
     sub="Alt başlık 'sub' argümanı ile yazılabilir")   
```

`?base::plot()` komutu ile girdi açıklamaları ve diğer özellikleri incelenebilir. 

```{r}
#| label: fig-plot2
#| fig-cap: "R plot fonksiyonu" 
#| echo: false
set.seed(2345)
x <- rnorm(100)
y <- 2*x+rnorm(100)
plot(x, y, 
     type = "p", # nokta grafiği
     main="X ve Y'nin serpilme çizimi", 
     xlab="x", 
     ylab="y", 
     sub="Kaynak: rassal sayı üreteci ile oluşturulmuştur",
     pch = 17,    # içi dolu üçgen
     col = "red", # sembol rengi = kırmızı
     font.main = 2, # başlık yazı tipi
     cex.main = 1.2,  # başlık yazı büyüklüğü
     font.axis = 3,   # eksenlerin yazı tipi, 3=italik
     cex.axis = 0.8,  # eksenlerin yazı büyüklüğü
     col.lab = "gray50"  # eksen rengi
)
```


::: {#fig-plotpch }
![](img/pch-linetype.PNG){width=80%}

Plot fonksiyonunda sembol (pch) ve çizgi tipleri (lty)
::: 

@fig-plotpch `plot()` fonksiyonunda kullanılan sembolleri ve çizgi tiplerini göstermektedir. 


### Eğri çizimi

Temel R'da bunun için `curve()` kullanılabilir. Yardım dosyasına ulaşmak için `?curve`.

Örnekler:

```{r}
# a linear function
curve(1+2*x, from=-2, to=2, xlab="x", ylab="" )
# add a quadratic function
curve(1+2*x-2*x^2, add = TRUE, col = "red" )
# cubic
curve(1+2*x-2*x^2+3*x^3, add = TRUE, col = "blue" )

```

Kendi cebirsel fonksiyonlarımızı `function()` ile oluşturup `curve()` ya da `plot()` yardımıyla çizebiliriz:

```{r}
# fonksiyonu tanımla
fun1 <- function(x) 2*sin(x)+cos(x)
# eğriyi çiz
curve(fun1, -pi, pi, n = 100) 
```

```{r}
# focus on the interval -2 < x < 2
plot(fun1, -2, 2)
```

## Çözümlü Alıştırmalar

::: {#exr-vektor1}
1'den 50'ye kadar sayıları içeren bir vektör oluşturun. Bu vektör içinden 7'nin katlarını bulun.

```{r}
# 1'den 50'ye kadar sayılar
vektor <- 1:50
# 7'nin katları
vektor[vektor %% 7 == 0]
```

::: 


::: {#exr-vektor2}
100 ile 200 arasındaki sayılardan sadece çift olanları içeren bir vektör oluşturun.
```{r}
# 100 ile 200 arasındaki çift sayılar
vektor2 <- 100:200
vektor2[vektor2 %% 2 == 0]
```

::: 


::: {#exr-vektor3}
5 elemanlı iki sayısal vektör oluşturun ve bu iki vektör arasında element-wise (eleman bazında) toplama ve çarpma işlemleri yapın.

```{r}
# İki vektör oluşturma
v1 <- c(1, 2, 3, 4, 5)
v2 <- c(6, 7, 8, 9, 10)
# Toplama ve çarpma
v1 + v2
v1 * v2
```

::: 


::: {#exr-vektor4}
10 elemanlı bir sayısal vektör oluşturun ve bu vektörün ilk yarısını ve son yarısını ayrı ayrı toplayın.
```{r}
# 10 elemanlı vektör
v3 <- 1:10
# İlk ve son yarısını toplama
sum(v3[1:5])
sum(v3[6:10])
```

::: 


::: {#exr-matris1}
4x4'lük bir matris oluşturun ve bu matrisin ikinci satırını ve üçüncü sütununu yazdırın.
```{r}
# Matris oluşturma
matris <- matrix(1:16, nrow = 4)
# İkinci satır ve üçüncü sütun
matris[2, ]
matris[, 3]
```
::: 


::: {#exr-matris2}
İki farklı 3x3'lük matris oluşturun ve bu matrisleri toplayın.
```{r}
# İki matris oluşturma ve toplama
m1 <- matrix(1:9, nrow = 3)
m2 <- matrix(9:1, nrow = 3)
m1 + m2
```

::: 


::: {#exr-matris3} 
5x5'lik bir matris oluşturun ve bu matrisin köşegen elemanlarını (diagonal elements) bulun.
```{r}
# 5x5 matris
matris2 <- matrix(1:25, nrow = 5)
# Köşegen elemanlar
diag(matris2)
```

::: 


::: {#exr-matris4} 
3x3'lük bir matris oluşturun ve bu matrisin her elemanının karesini alın.
```{r}
# 3x3 matris ve kareler
matris3 <- matrix(1:9, nrow = 3)
matris3^2
```

::: 


::: {#exr-liste1} 
Çeşitli veri tipleri içeren bir liste oluşturun ve bu listenin belirli bir elemanını başka bir değerle değiştirin.
```{r}
# Liste oluşturma ve değiştirme
liste <- list(sayi = 10, metin = "Merhaba", mantik = TRUE)
liste
liste$metin <- "Güle güle"
liste
```

::: 


::: {#exr-liste2} 
İç içe (nested) bir liste oluşturun ve iç içe listenin bir alt elemanına nasıl erişileceğini gösterin.
```{r}
# İç içe liste
ic_ice_liste <- list(sayilar = 1:5, harfler = letters[1:5], liste = liste)
ic_ice_liste$liste$metin
```

::: 


::: {#exr-df1} 
İsim, yaş ve gelir bilgilerini içeren bir veri çerçevesi oluşturun ve geliri 50,000'in üzerinde olan kişileri filtreleyin.
```{r}
# Veri çerçevesi oluşturma ve filtreleme
df <- data.frame(Isim = c("Ali", "Veli", "Ayşe"), Yas = c(32, 45, 25), Gelir = c(50000, 60000, 45000))
df
df[df$Gelir > 50000, ]
```

::: 


::: {#exr-df2} 
Farklı şehirlerde yaşayan kişilerin bilgilerini içeren bir veri çerçevesi oluşturun ve her şehirde kaç kişinin yaşadığını hesaplayın.
```{r}
# Şehir bilgisi içeren veri çerçevesi
sehir_df <- data.frame(Isim = c("Ali", "Veli", "Ayşe"), Sehir = c("İstanbul", "Ankara", "İstanbul"))
table(sehir_df$Sehir)
```

::: 


::: {#exr-dongu1} 
1'den 100'e kadar olan sayıları içeren bir vektör oluşturun ve bu vektördeki asal sayıları bulun.
```{r}
# Asal sayıları bulma 
# Bir asal sayı, yalnızca 1 ve kendisi olmak üzere tam olarak iki pozitif 
# böleni olan 1'den büyük bir doğal sayıdır.
#
asal_sayilar <- c()
for (i in 2:100) {
    if (i == 2) {
        asal_sayilar <- c(asal_sayilar, i)
    } else {
        asal_mi <- TRUE
        for (j in 2:(i-1)) {
            if (i %% j == 0) {
                asal_mi <- FALSE
                break
            }
        }
        if (asal_mi) {
            asal_sayilar <- c(asal_sayilar, i)
        }
    }
}
asal_sayilar
```

::: 


::: {#exr-dongu2} 
Bir karakter vektörü oluşturun ve her bir karakter dizisinin uzunluğunu for döngüsü kullanarak hesaplayın.
```{r}
# Karakter vektörü ve uzunlukları
kelimeler <- c("elma", "armut", "kiraz")
uzunluklar <- c()
for (kelime in kelimeler) {
  uzunluklar <- c(uzunluklar, nchar(kelime))
}
uzunluklar
```

::: 


::: {#exr-fonksiyon1} 
İki sayı alıp bu sayıların geometrik ortalamasını döndüren bir fonksiyon yazın.
```{r}
# Geometrik ortalama fonksiyonu
geo_ortalama <- function(a, b) {
  sqrt(a * b)
}
geo_ortalama(10,20)
```

::: 



::: {#exr-fonksiyon2} 
Bir sayı dizisi alıp bu dizideki en büyük ve en küçük değerleri döndüren bir fonksiyon yazın.
```{r}
# Max ve min döndüren fonksiyon
max_min <- function(sayilar) {
  c(max = max(sayilar), min = min(sayilar))
}
max_min(1:10)
```
::: 


## Problemler 


::: {#cnj-vektor1} 
Bir hafta boyunca (Pazartesi'den Pazar'a) her gün ölçülen maksimum sıcaklıklar (20, 22, 21, 23, 25, 27, 26) olsun. Bu vektörü tanımlayın ve sıcaklık değişimlerini gösteren bir başka vektör hesaplayın (her günün sıcaklığının bir önceki günden farkı).
::: 



::: {#cnj-vektor2} 
Bir sınavdan alınan puanlar şöyledir: (70, 85, 90, 75, 60, 65, 75, 80). Bu puanların aritmetik ortalamasını hesaplayın. Bu puanların ortalamadan ne kadar sapma gösterdiğini içeren bir vektör oluşturun.
::: 



::: {#cnj-matris1} 
8x8'lik bir matris kullanarak bir satranç tahtası oluşturun. Siyah kareler için 1, beyaz kareler için 0 kullanın. `heatmap()` ile görselleştirin. 

```{r}
#| echo: false
#| output: false
#| warning: false

r1 <- matrix(rep(c(1, 0), 4), nrow = 1, byrow = TRUE)  # Siyah başlayan satır
r2 <- matrix(rep(c(0, 1), 4), nrow = 1, byrow = TRUE)  # Beyaz başlayan satır
satranc_tahtasi <- rbind(r2, r1, r2, r1, r2, r1, r2, r1)  # Satranç tahtası

rownames(satranc_tahtasi) <- c("8", "7", "6", "5", "4", "3", "2", "1")
colnames(satranc_tahtasi) <- c("a", "b", "c", "d", "e", "f", "g", "h")
satranc_tahtasi
# görsel
heatmap(satranc_tahtasi, Rowv = NA, Colv = NA, col = c("white", "black"))
```

::: 



::: {#cnj-matris2} 
Beş şehir arasındaki mesafeleri içeren bir matris oluşturalım: 
```{r}
set.seed(1)
mesafeler <- matrix(sample(100:500, 25, replace = TRUE), nrow = 5)
rownames(mesafeler) <- c("A","B","C","D","E")
colnames(mesafeler) <- c("G","H","J","K","L")
mesafeler
```
Örneğin A şehri ile G şehri arasındaki mesafe 423 km'dir. Buna göre birbirine en yakın ve en uzak şehirleri bulun. 
::: 


::: {#cnj-liste1} 
İnsanların isim, yaş ve mesleklerini içeren aşağıdaki liste oluşturulmuştur: 
```{r}
kişiler <- list(c("Ali", 35, "Mühendis"), 
                c("Ayşe", 28, "Doktor"), 
                c("Mehmet", 42, "Öğretmen"))
```

Buna göre yaşı 30'dan büyük olan kişilerin sayısını bulun.
```{r, echo=FALSE, eval=FALSE}
yaşları_30dan_büyük_olanlar <- sapply(kişiler, function(x) x[2] > 30)
sum(yaşları_30dan_büyük_olanlar)
```
::: 



::: {#cnj-liste2} 
Çeşitli ürünlerin adı, fiyatı ve stok miktarını içeren bir veri çerçevesi oluşturulmuştur: 
```{r}
ürünler <- data.frame(Ürün = c("Kalem", "Defter", "Silgi"), 
                      Fiyat = c(1.50, 2.00, 0.75), 
                      Stok = c(12, 8, 15))
ürünler
```
Stok miktarı 10'dan az olan ürünleri listeleyin.

```{r, eval=FALSE, echo=FALSE}
düşük_stok <- ürünler[ürünler$Stok < 10, ]
```



::: 



::: {#cnj-dongu} 
Fibonacci serisi, her sayının kendisinden önce gelen iki sayının toplamı olduğu bir sayı dizisidir. Seri genellikle 0 ve 1 ile başlar, ardından her yeni sayı, önceki iki sayının toplamı olarak oluşturulur. Matematiksel olarak ifade edersek, Fibonacci serisinin $F_n$inci terimi aşağıdaki gibi tanımlanır:
$$
F_n = F_{n-1} + F_{n-2} 
$$
Burada $F_0=0$ ve $F_1=1$'dir. 

Buna göre, ilk 20 Fibonacci sayısını hesaplayın ve bir vektörde saklayın.
```{r, echo=FALSE, eval=FALSE}
fibonacci <- numeric(20)
fibonacci[1] <- 1
fibonacci[2] <- 1
for (i in 3:20) {
    fibonacci[i] <- fibonacci[i - 1] + fibonacci[i - 2]
}
```

::: 



::: {#cnj-fonksiyon1} 
Öğrencilerin aldığı dersler ve bu derslerdeki notları içeren bir liste oluşturun. Her öğrenci için genel not ortalamasını hesaplayan bir fonksiyon yazın.
```{r, eval=FALSE, echo=FALSE}
notlar <- list(Ali = c(80, 70, 90), 
               Ayşe = c(85, 95, 100), 
               Mehmet = c(60, 75, 65))
not_ortalaması <- sapply(notlar, mean)

```

::: 

::: {#cnj-harfler} 

Türkçe bir harfin alfabede kaçıncı harf olduğunu veren bir fonksiyon yazınız.
```{r, eval=FALSE, echo=FALSE}
kacinci_harf <- function (harf) {
  harfler <- c(letters[1:3], "Ç", letters[4:7], "ğ", letters[8], "ı", letters[9:15],
               "ö", letters[16], letters[18:19], "ş", letters[20:21], "ü", 
               letters[c(22,25,26)]) 
  HARFLER <- c(LETTERS[1:3], "Ç", LETTERS[4:7], "Ğ", LETTERS[8], "I", "İ", 
               LETTERS[10:15], "Ö", LETTERS[16], LETTERS[18:19], "Ş", 
               LETTERS[20:21], "Ü", LETTERS[c(22,25,26)]) 
  
  if (length(which(harfler == harf)) == 0) {
     paste0(harf, " alfabenin ", which(HARFLER == harf), ". harfidir")
  } else {
     paste0(harf, " alfabenin ", which(harfler == harf), ". harfidir")
  }
 
}
kacinci_harf("h")
kacinci_harf("İ")
kacinci_harf("Ş")
```
::: 




